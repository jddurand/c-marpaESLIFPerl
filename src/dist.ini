name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; ---------------------------------------------------
; We use @Starter::Git with the following variations:
; ---------------------------------------------------

; Next version is provided by Git::NextVersion
; ---------------------------------------------------
[Git::NextVersion]
version_regexp = ^v?(\d+\.\d+)$

; "# VERSION" and "# AUTHORITY" annotations
; ---------------------------------------------------
[OurPkgVersion]
[Authority]
locate_comment = 1

; Pod are managed using Pod::Weaver::PluginBundle::RJBS
; ---------------------------------------------------
; - Because he knows how to insert Contributor section before Legal section
; - We add that explicitly to DevelopRequires because it seems it is not automatically discovered.
[Git::Contributors]
[PodWeaver]
config_plugin = @RJBS
[Prereqs / DevelopRequires ]
Pod::Weaver::PluginBundle::RJBS = 0

; Add authordeps as develop/requires
; ---------------------------------------------------
[Prereqs::AuthorDeps]

; Add xt tests
; ---------------------------------------------------
[Test::Perl::Critic]     ; xt/author/critic.t
[MetaTests]              ; xt/author/distmeta.t
[Test::EOL]              ; xt/author/eol.t
[Test::MinimumVersion]   ; xt/author/minimum-version.t
[MojibakeTests]          ; xt/author/mojibake.t
[Test::NoTabs]           ; xt/author/no-tabs.t
[PodCoverageTests]       ; xt/author/pod-coverage.t
[Test::Pod::LinkCheck]   ; xt/author/pod-linkcheck.t
[Test::Portability]      ; xt/author/portability.t
options = test_one_dot = 0
[Test::Synopsis]         ; xt/author/synopsis.t
[Test::Version]          ; xt/author/test-version.t
[Test::CPAN::Changes]    ; xt/release/cpan-changes.t
[Test::Kwalitee]         ; xt/release/kwalitee.t
[Test::CPAN::Meta::JSON] ; xt/release/meta-json.t

; Meta resources use [AutoMetaResources] convenient %{dist} to set homepage, [GitHub::Meta] for the rest
; ---------------------------------------------------
[AutoMetaResources]
homepage = https://metacpan.org/release/%{dist}
[GitHub::Meta]
homepage = 0

; Determine minimum perl version
; ---------------------------------------------------
[MinimumPerl]

; Generate a cpanfile
; ---------------------------------------------------
[CPANFile]

; Generate a Changes file
; ---------------------------------------------------
[ChangelogFromGit::CPAN::Changes]
file_name = Changes
group_by_author = 1 ; default 0
show_author_email = 1 ; default 0
tag_regexp  = ^v?(\d+\.\d+)$

; @Starter::Git Bundle with regeneration of:
; Makefile.PL
; META.json
; README.pod
; ---------------------------------------------------
[@Starter::Git]
revision = 5
-remove = Pod2Readme
Git::GatherDir.exclude_filename = LICENSE
Test::Compile.xt_mode = 0
Git::Check.allow_dirty[0] = Changes
Git::Check.allow_dirty[1] = META.json
Git::Check.allow_dirty[2] = README.pod
Git::Check.allow_dirty[3] = Makefile.PL
Git::Check.allow_dirty[4] = cpanfile
Git::Check.untracked_files = warn ; For the case where generated files do not yet exist
regenerate = Changes
regenerate = META.json
regenerate = README.pod
regenerate = Makefile.PL
regenerate = cpanfile
installer = MakeMaker::Awesome
MakeMaker::Awesome.delimiter = |
MakeMaker::Awesome.header[  0] = |use Capture::Tiny ':all';
MakeMaker::Awesome.header[  1] = |use ExtUtils::Constant qw /constant_types C_constant XS_constant autoload/;
MakeMaker::Awesome.header[  2] = |use Probe::Perl;
MakeMaker::Awesome.header[  3] = |
MakeMaker::Awesome.header[  4] = |my $perl_exe = Probe::Perl->find_perl_interpreter();
MakeMaker::Awesome.header[  5] = |#
MakeMaker::Awesome.header[  6] = |# Get cmake3 executable (version >= 3.26)
MakeMaker::Awesome.header[  7] = |#
MakeMaker::Awesome.header[  8] = |print "Checking cmake3\n"
MakeMaker::Awesome.header[  9] = |my $cmake3_exe = capture_stdout {
MakeMaker::Awesome.header[ 10] = |  my @args = ($perl_exe, 'get_cmake3.pl');
MakeMaker::Awesome.header[ 11] = |  system(@args) || die "Cannot get cmake, $!";
MakeMaker::Awesome.header[ 12] = |}
MakeMaker::Awesome.header[ 13] = |print "Using $cmake3_exe\n"
MakeMaker::Awesome.header[ 14] = |#
MakeMaker::Awesome.header[ 15] = |# Install locally marpaESLIF using cmake
MakeMaker::Awesome.header[ 16] = |#
MakeMaker::Awesome.header[ 17] = |print "Checking marpaESLIF\n"
MakeMaker::Awesome.header[ 18] = |{
MakeMaker::Awesome.header[ 19] = |  my @args = ($perl_exe, 'call_cmake3.pl', $cmake3_exe);
MakeMaker::Awesome.header[ 20] = |  system(@args) || die "Cannot call cmake, $!";
MakeMaker::Awesome.header[ 21] = |}
MakeMaker::Awesome.header[ 22] = |
MakeMaker::Awesome.header[ 23] = |my $fh;
MakeMaker::Awesome.header[ 24] = |print "Generating constant types\n";
MakeMaker::Awesome.header[ 25] = |open($fh, '>', 'c-constant-types.inc') || die "Cannot open c-constant-types.inc, $!";
MakeMaker::Awesome.header[ 26] = |print $fh constant_types();
MakeMaker::Awesome.header[ 27] = |close($fh) || warn "Failed to close c-constant-types.inc, $!";
MakeMaker::Awesome.header[ 28] = |
MakeMaker::Awesome.header[ 29] = |my %types = ( 'event' => { pkg => 'MarpaX::ESLIF::Event::Type', constants => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/] }, 'value' => { pkg => 'MarpaX::ESLIF::Value::Type', constants => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_BOOL MARPAESLIF_VALUE_TYPE_STRING MARPAESLIF_VALUE_TYPE_ROW MARPAESLIF_VALUE_TYPE_TABLE MARPAESLIF_VALUE_TYPE_LONG_DOUBLE/] }, 'loggerLevel' => { pkg => 'MarpaX::ESLIF::Logger::Level', constants => [qw/GENERICLOGGER_LOGLEVEL_TRACE GENERICLOGGER_LOGLEVEL_DEBUG GENERICLOGGER_LOGLEVEL_INFO GENERICLOGGER_LOGLEVEL_NOTICE GENERICLOGGER_LOGLEVEL_WARNING GENERICLOGGER_LOGLEVEL_ERROR GENERICLOGGER_LOGLEVEL_CRITICAL GENERICLOGGER_LOGLEVEL_ALERT GENERICLOGGER_LOGLEVEL_EMERGENCY/] }, 'rulePropertyBitSet' => { pkg => 'MarpaX::ESLIF::Rule::PropertyBitSet', constants => [qw/MARPAESLIF_RULE_IS_ACCESSIBLE MARPAESLIF_RULE_IS_NULLABLE MARPAESLIF_RULE_IS_NULLING MARPAESLIF_RULE_IS_LOOP MARPAESLIF_RULE_IS_PRODUCTIVE/] }, 'symbolPropertyBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::PropertyBitSet', constants => [qw/MARPAESLIF_SYMBOL_IS_ACCESSIBLE MARPAESLIF_SYMBOL_IS_NULLABLE MARPAESLIF_SYMBOL_IS_NULLING MARPAESLIF_SYMBOL_IS_PRODUCTIVE MARPAESLIF_SYMBOL_IS_START MARPAESLIF_SYMBOL_IS_TERMINAL/] }, 'symbolEventBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::EventBitSet', constants => [qw/MARPAESLIF_SYMBOL_EVENT_COMPLETION MARPAESLIF_SYMBOL_EVENT_NULLED MARPAESLIF_SYMBOL_EVENT_PREDICTION/] }, 'symbol' => { pkg => 'MarpaX::ESLIF::Symbol::Type', constants => [qw/MARPAESLIF_SYMBOLTYPE_TERMINAL MARPAESLIF_SYMBOLTYPE_META/] });
MakeMaker::Awesome.header[ 30] = |
MakeMaker::Awesome.header[ 31] = |foreach (sort keys %types) {
MakeMaker::Awesome.header[ 32] = |  my $pkg = $types{$_}->{pkg};
MakeMaker::Awesome.header[ 33] = |  print "Generating $pkg C $_ types\n";
MakeMaker::Awesome.header[ 34] = |  open($fh, '>', "c-$_-types.inc") || die "Cannot open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 35] = |  print $fh C_constant($pkg, "${_}_constant", undef, undef, undef, undef, @{$types{$_}->{constants}});
MakeMaker::Awesome.header[ 36] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 37] = |
MakeMaker::Awesome.header[ 38] = |  # This is a bit vicious but in our case these are NOT macros but ENUMS !
MakeMaker::Awesome.header[ 39] = |  # We know what were are doing and replace all #ifdef MARPAESLIF_xxx and #ifdef GENERICLOGGER_xxx by #if 1
MakeMaker::Awesome.header[ 40] = |
MakeMaker::Awesome.header[ 41] = |  print "Tweaking $pkg C $_ types to work with enums\n";
MakeMaker::Awesome.header[ 42] = |  open($fh, '<', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 43] = |  my $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[ 44] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 45] = |  $content =~ s/^#\s*ifdef\s+(?:MARPAESLIF_|GENERICLOGGER_).*?$/#if 1/smg;
MakeMaker::Awesome.header[ 46] = |  open($fh, '>', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 47] = |  print $fh $content;
MakeMaker::Awesome.header[ 48] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 49] = |
MakeMaker::Awesome.header[ 50] = |  print "Generating $pkg XS $_ types\n";
MakeMaker::Awesome.header[ 51] = |  open($fh, '>', "xs-$_-types.inc") || die "Cannot open xs-$_-types.inc, $!";
MakeMaker::Awesome.header[ 52] = |  print $fh XS_constant($pkg, 'IV', 'constant', "${_}_constant");
MakeMaker::Awesome.header[ 53] = |  close($fh) || warn "Failed to close xs-$_-types.inc, $!";
MakeMaker::Awesome.header[ 54] = |
MakeMaker::Awesome.header[ 55] = |  print "Generating $pkg AUTOLOAD\n";
MakeMaker::Awesome.header[ 56] = |  my $autoload = replace_autoload_tabs(autoload($pkg, '5.10', 1));
MakeMaker::Awesome.header[ 57] = |
MakeMaker::Awesome.header[ 58] = |  my @pkg = split(/::/, $pkg);
MakeMaker::Awesome.header[ 59] = |  $pkg[-1] .= '.pm';
MakeMaker::Awesome.header[ 60] = |  my $pkgfile = File::Spec->catfile('lib', @pkg);
MakeMaker::Awesome.header[ 61] = |  print "Pushing AUTOLOAD into $pkgfile\n";
MakeMaker::Awesome.header[ 62] = |  open($fh, '<', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[ 63] = |  $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[ 64] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[ 65] = |  $content =~ s/^#\s*AUTOLOAD.*?$/\n$autoload\n/sm;
MakeMaker::Awesome.header[ 66] = |  open($fh, '>', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[ 67] = |  print $fh $content;
MakeMaker::Awesome.header[ 68] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[ 69] = |}
MakeMaker::Awesome.header[ 70] = |sub replace_autoload_tabs {
MakeMaker::Awesome.header[ 71] = |    my ($autoload) = @_;
MakeMaker::Awesome.header[ 72] = |    $autoload =~ s/^\t/        /mg; # For the cases we know for pretty indentation
MakeMaker::Awesome.header[ 73] = |    $autoload =~ s/\t/    /g; # For all the other cases
MakeMaker::Awesome.header[ 74] = |    return $autoload;
MakeMaker::Awesome.header[ 75] = |}
MakeMaker::Awesome.WriteMakefile_arg[0] = OBJECT => 'ESLIF$(OBJ_EXT)'
MakeMaker::Awesome.WriteMakefile_arg[1] = depend => { 'ESLIF$(OBJ_EXT)' => 'marpaESLIF' }
;MakeMaker::Awesome.footer[  0] = |package MY;
;MakeMaker::Awesome.footer[  1] = |sub postamble {
;MakeMaker::Awesome.footer[  2] = |  return "
;MakeMaker::Awesome.footer[  3] = |marpaESLIF:
;MakeMaker::Awesome.footer[  4] = |\t\$(CMAKE) -S inc/marpaESLIF -B inc/marpaESLIF-build
;MakeMaker::Awesome.footer[  5] = |
;MakeMaker::Awesome.footer[  6] = |"
;MakeMaker::Awesome.footer[  7] = |}
;MakeMaker::Awesome.footer[  8] = |
;MakeMaker::Awesome.footer[  9] = |sub const_config {
;MakeMaker::Awesome.footer[ 10] = |  my $mm = shift;
;MakeMaker::Awesome.footer[ 11] = |  my $const_config = $mm->SUPER::const_config(@_);
;MakeMaker::Awesome.footer[ 12] = |  $const_config .= "\nCMAKE = " . $mm->quote_literal($cmake). "\n";
;MakeMaker::Awesome.footer[ 13] = |  return $const_config
;MakeMaker::Awesome.footer[ 14] = |}

; Do not require Thread on non-threaded perls
; ---------------------------------------------------
[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}
