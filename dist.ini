name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; ---------------------------------------------------
; We use @Starter::Git with the following variations:
; ---------------------------------------------------

; Next version is provided by Git::NextVersion
; ---------------------------------------------------
[Git::NextVersion]
version_regexp = ^v?(\d+\.\d+)$

; "# VERSION" and "# AUTHORITY" annotations
; ---------------------------------------------------
[OurPkgVersion]
[Authority]
locate_comment = 1

; Pod are managed using Pod::Weaver::PluginBundle::RJBS
; ---------------------------------------------------
; - Because he knows how to insert Contributor section before Legal section
; - We add that explicitly to DevelopRequires because it seems it is not automatically discovered.
[Git::Contributors]
[PodWeaver]
config_plugin = @RJBS
[Prereqs / DevelopRequires ]
Pod::Weaver::PluginBundle::RJBS = 0

; Add authordeps as develop/requires
; ---------------------------------------------------
[Prereqs::AuthorDeps]

; Add xt tests
; ---------------------------------------------------
[Test::Perl::Critic]     ; xt/author/critic.t
[MetaTests]              ; xt/author/distmeta.t
[Test::EOL]              ; xt/author/eol.t
[Test::MinimumVersion]   ; xt/author/minimum-version.t
[MojibakeTests]          ; xt/author/mojibake.t
[Test::NoTabs]           ; xt/author/no-tabs.t
[PodCoverageTests]       ; xt/author/pod-coverage.t
[Test::Pod::LinkCheck]   ; xt/author/pod-linkcheck.t
[Test::Portability]      ; xt/author/portability.t
options = test_one_dot = 0
[Test::Synopsis]         ; xt/author/synopsis.t
[Test::Version]          ; xt/author/test-version.t
[Test::CPAN::Changes]    ; xt/release/cpan-changes.t
[Test::Kwalitee]         ; xt/release/kwalitee.t
[Test::CPAN::Meta::JSON] ; xt/release/meta-json.t

; Meta resources use [AutoMetaResources] convenient %{dist} to set homepage, [GitHub::Meta] for the rest
; ---------------------------------------------------
[AutoMetaResources]
homepage = https://metacpan.org/release/%{dist}
[GitHub::Meta]
homepage = 0

; Determine minimum perl version
; ---------------------------------------------------
[MinimumPerl]

; Generate a cpanfile
; ---------------------------------------------------
[CPANFile]

; Generate a Changes file
; ---------------------------------------------------
[ChangelogFromGit::CPAN::Changes]
file_name = Changes
group_by_author = 1 ; default 0
show_author_email = 1 ; default 0
tag_regexp  = ^v?(\d+\.\d+)$

; @Starter::Git Bundle with regeneration of:
; Makefile.PL
; META.json
; README.pod
; ---------------------------------------------------
[@Starter::Git]
revision = 5
-remove = Pod2Readme
Git::GatherDir.exclude_filename = LICENSE
Test::Compile.xt_mode = 0
Git::Check.allow_dirty[0] = Changes
Git::Check.allow_dirty[1] = META.json
Git::Check.allow_dirty[2] = README.pod
Git::Check.allow_dirty[3] = Makefile.PL
Git::Check.allow_dirty[4] = cpanfile
Git::Check.untracked_files = warn ; For the case where generated files do not yet exist
regenerate = Changes
regenerate = META.json
regenerate = README.pod
regenerate = Makefile.PL
regenerate = cpanfile
installer = MakeMaker::Awesome
MakeMaker::Awesome.delimiter = |
MakeMaker::Awesome.header[0] = |use Alien::cmake3;
MakeMaker::Awesome.header[1] = |use ExtUtils::Constant qw /constant_types C_constant XS_constant autoload/;
MakeMaker::Awesome.header[382] = |
MakeMaker::Awesome.header[383] = |my $fh;
MakeMaker::Awesome.header[384] = |print "Generating constant types\n";
MakeMaker::Awesome.header[385] = |open($fh, '>', 'c-constant-types.inc') || die "Cannot open c-constant-types.inc, $!";
MakeMaker::Awesome.header[386] = |print $fh constant_types();
MakeMaker::Awesome.header[387] = |close($fh) || warn "Failed to close c-constant-types.inc, $!";
MakeMaker::Awesome.header[388] = |
MakeMaker::Awesome.header[389] = |my %types = ( 'event' => { pkg => 'MarpaX::ESLIF::Event::Type', constants => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/] }, 'value' => { pkg => 'MarpaX::ESLIF::Value::Type', constants => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_BOOL MARPAESLIF_VALUE_TYPE_STRING MARPAESLIF_VALUE_TYPE_ROW MARPAESLIF_VALUE_TYPE_TABLE MARPAESLIF_VALUE_TYPE_LONG_DOUBLE/] }, 'loggerLevel' => { pkg => 'MarpaX::ESLIF::Logger::Level', constants => [qw/GENERICLOGGER_LOGLEVEL_TRACE GENERICLOGGER_LOGLEVEL_DEBUG GENERICLOGGER_LOGLEVEL_INFO GENERICLOGGER_LOGLEVEL_NOTICE GENERICLOGGER_LOGLEVEL_WARNING GENERICLOGGER_LOGLEVEL_ERROR GENERICLOGGER_LOGLEVEL_CRITICAL GENERICLOGGER_LOGLEVEL_ALERT GENERICLOGGER_LOGLEVEL_EMERGENCY/] }, 'rulePropertyBitSet' => { pkg => 'MarpaX::ESLIF::Rule::PropertyBitSet', constants => [qw/MARPAESLIF_RULE_IS_ACCESSIBLE MARPAESLIF_RULE_IS_NULLABLE MARPAESLIF_RULE_IS_NULLING MARPAESLIF_RULE_IS_LOOP MARPAESLIF_RULE_IS_PRODUCTIVE/] }, 'symbolPropertyBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::PropertyBitSet', constants => [qw/MARPAESLIF_SYMBOL_IS_ACCESSIBLE MARPAESLIF_SYMBOL_IS_NULLABLE MARPAESLIF_SYMBOL_IS_NULLING MARPAESLIF_SYMBOL_IS_PRODUCTIVE MARPAESLIF_SYMBOL_IS_START MARPAESLIF_SYMBOL_IS_TERMINAL/] }, 'symbolEventBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::EventBitSet', constants => [qw/MARPAESLIF_SYMBOL_EVENT_COMPLETION MARPAESLIF_SYMBOL_EVENT_NULLED MARPAESLIF_SYMBOL_EVENT_PREDICTION/] }, 'symbol' => { pkg => 'MarpaX::ESLIF::Symbol::Type', constants => [qw/MARPAESLIF_SYMBOLTYPE_TERMINAL MARPAESLIF_SYMBOLTYPE_META/] });
MakeMaker::Awesome.header[390] = |
MakeMaker::Awesome.header[391] = |foreach (sort keys %types) {
MakeMaker::Awesome.header[392] = |  my $pkg = $types{$_}->{pkg};
MakeMaker::Awesome.header[393] = |  print "Generating $pkg C $_ types\n";
MakeMaker::Awesome.header[394] = |  open($fh, '>', "c-$_-types.inc") || die "Cannot open c-$_-types.inc, $!";
MakeMaker::Awesome.header[395] = |  print $fh C_constant($pkg, "${_}_constant", undef, undef, undef, undef, @{$types{$_}->{constants}});
MakeMaker::Awesome.header[396] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[397] = |
MakeMaker::Awesome.header[398] = |  # This is a bit vicious but in our case these are NOT macros but ENUMS !
MakeMaker::Awesome.header[399] = |  # We know what were are doing and replace all #ifdef MARPAESLIF_xxx and #ifdef GENERICLOGGER_xxx by #if 1
MakeMaker::Awesome.header[400] = |
MakeMaker::Awesome.header[401] = |  print "Tweaking $pkg C $_ types to work with enums\n";
MakeMaker::Awesome.header[402] = |  open($fh, '<', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[403] = |  my $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[404] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[405] = |  $content =~ s/^#\s*ifdef\s+(?:MARPAESLIF_|GENERICLOGGER_).*?$/#if 1/smg;
MakeMaker::Awesome.header[406] = |  open($fh, '>', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[407] = |  print $fh $content;
MakeMaker::Awesome.header[408] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[409] = |
MakeMaker::Awesome.header[410] = |  print "Generating $pkg XS $_ types\n";
MakeMaker::Awesome.header[411] = |  open($fh, '>', "xs-$_-types.inc") || die "Cannot open xs-$_-types.inc, $!";
MakeMaker::Awesome.header[412] = |  print $fh XS_constant($pkg, 'IV', 'constant', "${_}_constant");
MakeMaker::Awesome.header[413] = |  close($fh) || warn "Failed to close xs-$_-types.inc, $!";
MakeMaker::Awesome.header[414] = |
MakeMaker::Awesome.header[415] = |  print "Generating $pkg AUTOLOAD\n";
MakeMaker::Awesome.header[416] = |  my $autoload = replace_autoload_tabs(autoload($pkg, '5.10', 1));
MakeMaker::Awesome.header[417] = |
MakeMaker::Awesome.header[418] = |  my @pkg = split(/::/, $pkg);
MakeMaker::Awesome.header[419] = |  $pkg[-1] .= '.pm';
MakeMaker::Awesome.header[420] = |  my $pkgfile = File::Spec->catfile('lib', @pkg);
MakeMaker::Awesome.header[421] = |  print "Pushing AUTOLOAD into $pkgfile\n";
MakeMaker::Awesome.header[422] = |  open($fh, '<', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[423] = |  $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[424] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[425] = |  $content =~ s/^#\s*AUTOLOAD.*?$/\n$autoload\n/sm;
MakeMaker::Awesome.header[426] = |  open($fh, '>', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[427] = |  print $fh $content;
MakeMaker::Awesome.header[428] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[429] = |}
MakeMaker::Awesome.header[550] = |sub replace_autoload_tabs {
MakeMaker::Awesome.header[551] = |    my ($autoload) = @_;
MakeMaker::Awesome.header[552] = |    $autoload =~ s/^\t/        /mg; # For the cases we know for pretty indentation
MakeMaker::Awesome.header[553] = |    $autoload =~ s/\t/    /g; # For all the other cases
MakeMaker::Awesome.header[554] = |    return $autoload;
MakeMaker::Awesome.header[555] = |}
MakeMaker::Awesome.WriteMakefile_arg[0] = OBJECT => 'ESLIF$(OBJ_EXT)'

; Do not require Thread on non-threaded perls
; ---------------------------------------------------
[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}
