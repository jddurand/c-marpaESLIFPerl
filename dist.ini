name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; ---------------------------------------------------
; We use @Starter::Git with the following variations:
; ---------------------------------------------------

; Next version is provided by Git::NextVersion
; ---------------------------------------------------
[Git::NextVersion]
version_regexp = ^v?(\d+\.\d+)$

; "# VERSION" and "# AUTHORITY" annotations
; ---------------------------------------------------
[OurPkgVersion]
[Authority]
locate_comment = 1

; Pod are managed using Pod::Weaver::PluginBundle::RJBS
; ---------------------------------------------------
; - Because he knows how to insert Contributor section before Legal section
; - We add that explicitly to DevelopRequires because it seems it is not automatically discovered.
[Git::Contributors]
[PodWeaver]
config_plugin = @RJBS
[Prereqs / DevelopRequires ]
Pod::Weaver::PluginBundle::RJBS = 0

; Add authordeps as develop/requires
; ---------------------------------------------------
[Prereqs::AuthorDeps]

; Add xt tests
; ---------------------------------------------------
[Test::Perl::Critic]     ; xt/author/critic.t
[MetaTests]              ; xt/author/distmeta.t
[Test::EOL]              ; xt/author/eol.t
[Test::MinimumVersion]   ; xt/author/minimum-version.t
[MojibakeTests]          ; xt/author/mojibake.t
[Test::NoTabs]           ; xt/author/no-tabs.t
[Test::Pod::Coverage::Configurable] ; xt/author/pod-coverage.t
also_private = allocate             ; Defined in the XS
also_private = allocate_newFrom     ; Defined in the XS
also_private = meta_allocate        ; Defined in the XS
also_private = regex_allocate       ; Defined in the XS
also_private = string_allocate      ; Defined in the XS
also_private = dispose              ; Defined in the XS
also_private = constant             ; A bug IMHO
trustme = MarpaX::ESLIF::Grammar::Symbol::Properties => qr/^(?:new)$/ ; Used in the XS - completely internal
trustme = MarpaX::ESLIF::Grammar::Rule::Properties => qr/^(?:new)$/ ; Used in the XS - completely internal
[Test::Pod::LinkCheck]   ; xt/author/pod-linkcheck.t
[Test::Portability]      ; xt/author/portability.t
options = test_one_dot = 0
[Test::Synopsis]         ; xt/author/synopsis.t
[Test::Version]          ; xt/author/test-version.t
[Test::CPAN::Changes]    ; xt/release/cpan-changes.t
[Test::Kwalitee]         ; xt/release/kwalitee.t
skiptest = has_readme               ; It is normal we do not have README, metacpan tells everything that is needed.
[Test::CPAN::Meta::JSON] ; xt/release/meta-json.t

; Meta resources use [AutoMetaResources] convenient %{dist} to set homepage, [GitHub::Meta] for the rest
; ---------------------------------------------------
[AutoMetaResources]
homepage = https://metacpan.org/release/%{dist}
[GitHub::Meta]
homepage = 0

; Determine minimum perl version
; ---------------------------------------------------
[MinimumPerl]

; Find prereqs
; ------------
[AutoPrereqs]

; Some hardcoded prereqs because of MakeMaker::Awesome hooks (see below)
; ----------------------------------------------------------------------
[Prereqs / ConfigureRequires]
Config::AutoConf = 0
ExtUtils::CBuilder = 0.280224 ; 0.280224 is to make sure we have the support of $ENV{CXX}
ExtUtils::Constant = 0
File::chdir = 0
File::Find = 0
File::Path = 0
Probe::Perl = 0
Try::Tiny = 0

[Prereqs / ConfigureSuggests]
; Well, ExtUtils::CppGuess does not install everywhere, in particular there is a problem with Sun C compiler.
; This is why we have an explicit copy in our inc that we enclose with a try/catch
ExtUtils::CppGuess = 0.26

[Prereqs / TestRequires]
Test::More = 1.3
Test::More::UTF8 = 0
Test::Deep = 1.128
Log::Any = 0
Log::Any::Adapter = 0
Data::Dumper = 0
Safe::Isa = 0
Try::Tiny = 0

; Generate a cpanfile
; ---------------------------------------------------
[CPANFile]

; Generate a Changes file
; ---------------------------------------------------
[ChangelogFromGit::CPAN::Changes]
file_name = Changes
group_by_author = 1 ; default 0
show_author_email = 1 ; default 0
tag_regexp  = ^v?(\d+\.\d+)$

; Gather tuning
; ---------------------------------------------------
[GatherFile]
filename = .perlcriticrc ; Explicitly add it for xtest
[GatherDir / SpecFiles]
root = etc/tarballs
prefix = etc/tarballs

; @Starter::Git Bundle with regeneration of:
; Makefile.PL
; META.json
; README.pod
; ---------------------------------------------------
[@Starter::Git]
revision = 5
-remove = Pod2Readme
Git::GatherDir.exclude_filename = LICENSE
Git::GatherDir.exclude_match = ^CMakeLists
Test::Compile.xt_mode = 0
PruneCruft.except[0] = ^\.perlcriticrc$
Git::Check.allow_dirty[0] = Changes
Git::Check.allow_dirty[1] = META.json
Git::Check.allow_dirty[2] = README.pod
Git::Check.allow_dirty[3] = Makefile.PL
Git::Check.allow_dirty[4] = cpanfile
Git::Check.untracked_files = warn ; For the case where generated files do not yet exist
regenerate = Changes
regenerate = META.json
regenerate = README.pod
regenerate = Makefile.PL
regenerate = cpanfile
installer = MakeMaker::Awesome
MakeMaker::Awesome.delimiter = |
MakeMaker::Awesome.header[  0] = |my $have_cppguess;
MakeMaker::Awesome.header[  1] = |BEGIN {
MakeMaker::Awesome.header[  2] = |  use File::Spec;                     # Formally it is not necessary I believe to do it here
MakeMaker::Awesome.header[  3] = |  # Make sure we have our 'inc' directory prepended the perl search path
MakeMaker::Awesome.header[  4] = |  my $inc_dir = File::Spec->catdir(File::Spec->curdir, 'inc');
MakeMaker::Awesome.header[  5] = |  unshift(@INC, $inc_dir);
MakeMaker::Awesome.header[  6] = |  #
MakeMaker::Awesome.header[  7] = |  # ExtUtils::CppGuess does not install everywhere.
MakeMaker::Awesome.header[  8] = |  # This is why we provide it explicitely, we are ok if it fails at run-time
MakeMaker::Awesome.header[  9] = |  # by enclosing its usage in try/catch
MakeMaker::Awesome.header[ 10] = |  #
MakeMaker::Awesome.header[ 11] = |  $have_cppguess = eval 'use ExtUtils::CppGuess 0.26; 1;';
MakeMaker::Awesome.header[ 12] = |}
MakeMaker::Awesome.header[ 13] = |use Config;
MakeMaker::Awesome.header[ 14] = |use Config::AutoConf;
MakeMaker::Awesome.header[ 15] = |use ExtUtils::CBuilder;
MakeMaker::Awesome.header[ 16] = |use ExtUtils::Constant qw /constant_types C_constant XS_constant autoload/;
MakeMaker::Awesome.header[ 17] = |use Probe::Perl;
MakeMaker::Awesome.header[ 18] = |use POSIX qw/EXIT_SUCCESS/;
MakeMaker::Awesome.header[ 19] = |use Try::Tiny;
MakeMaker::Awesome.header[ 20] = |
MakeMaker::Awesome.header[ 21] = |autoflush STDOUT 1;
MakeMaker::Awesome.header[ 22] = |autoflush STDERR 1;
MakeMaker::Awesome.header[ 23] = |
MakeMaker::Awesome.header[ 24] = |#
MakeMaker::Awesome.header[ 25] = |# extra_linker_flags must be hacked because of C++ stuff that is in tconv
MakeMaker::Awesome.header[ 26] = |#
MakeMaker::Awesome.header[ 27] = |my %cbuilder_config = ExtUtils::CBuilder->new()->get_config;
MakeMaker::Awesome.header[ 28] = |my $cc = $cbuilder_config{cc} // 'cc';
MakeMaker::Awesome.header[ 29] = |my $extra_linker_flags = '';
MakeMaker::Awesome.header[ 30] = |my $ac = Config::AutoConf->new();
MakeMaker::Awesome.header[ 31] = |$ac->msg_checking(sprintf "if this is Sun C compiler");
MakeMaker::Awesome.header[ 32] = |if ($ac->link_if_else("#ifdef __SUNPRO_C\n#else\n#error \"this is not Sun C compiler\"\n#endif\nint main() { return 0; }")) {
MakeMaker::Awesome.header[ 33] = |  $ac->msg_result('yes');
MakeMaker::Awesome.header[ 34] = |    $ac->msg_notice("Adding -lCrun to linker flags");
MakeMaker::Awesome.header[ 35] = |    $extra_linker_flags = '-lCrun';
MakeMaker::Awesome.header[ 36] = |} else {
MakeMaker::Awesome.header[ 37] = |  $ac->msg_result('no');
MakeMaker::Awesome.header[ 38] = |  if ($have_cppguess) {
MakeMaker::Awesome.header[ 39] = |    try {
MakeMaker::Awesome.header[ 40] = |      my $guesser = ExtUtils::CppGuess->new(cc => $cc);
MakeMaker::Awesome.header[ 41] = |      my %module_build_options = $guesser->module_build_options;
MakeMaker::Awesome.header[ 42] = |      my $extra_ldflags_guess  = $module_build_options{extra_linker_flags} // '';
MakeMaker::Awesome.header[ 43] = |      if (defined($extra_ldflags_guess) && (length($extra_ldflags_guess) > 0)) {
MakeMaker::Awesome.header[ 44] = |        $ac->msg_notice("Adding $extra_ldflags_guess to_linker flags");
MakeMaker::Awesome.header[ 45] = |        $extra_linker_flags = $extra_ldflags_guess;
MakeMaker::Awesome.header[ 46] = |      }
MakeMaker::Awesome.header[ 47] = |    };
MakeMaker::Awesome.header[ 48] = |  }
MakeMaker::Awesome.header[ 49] = |}
MakeMaker::Awesome.header[ 50] = |{
MakeMaker::Awesome.header[ 51] = |  #
MakeMaker::Awesome.header[ 52] = |  # We want to align lua integer type with perl ivtype
MakeMaker::Awesome.header[ 53] = |  #
MakeMaker::Awesome.header[ 54] = |  my $CCFLAGS = '';
MakeMaker::Awesome.header[ 55] = |  my $ivtype = $Config{ivtype} || '';
MakeMaker::Awesome.header[ 56] = |  if ($ivtype eq 'int') {
MakeMaker::Awesome.header[ 57] = |    $ac->msg_notice("Use int for lua_Integer");
MakeMaker::Awesome.header[ 58] = |    $CCFLAGS .= " -DLUA_INT_TYPE=1";
MakeMaker::Awesome.header[ 59] = |  } elsif ($ivtype eq 'long') {
MakeMaker::Awesome.header[ 60] = |    $ac->msg_notice("Use long for lua_Integer");
MakeMaker::Awesome.header[ 61] = |    $CCFLAGS .= " -DLUA_INT_TYPE=2";
MakeMaker::Awesome.header[ 62] = |  } elsif ($ivtype eq 'long long') {
MakeMaker::Awesome.header[ 63] = |    $ac->msg_notice("Use long long for lua_Integer");
MakeMaker::Awesome.header[ 64] = |    $CCFLAGS .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 65] = |  } else {
MakeMaker::Awesome.header[ 66] = |    $ac->msg_notice("No exact map found in lua for perl integer type \"$ivtype\": use long long for lua_Integer");
MakeMaker::Awesome.header[ 67] = |    $CCFLAGS .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 68] = |  }
MakeMaker::Awesome.header[ 69] = |  #
MakeMaker::Awesome.header[ 70] = |  # ./.. and lua float type with perl nvtype
MakeMaker::Awesome.header[ 71] = |  #
MakeMaker::Awesome.header[ 72] = |  my $nvtype = $Config{nvtype} || '';
MakeMaker::Awesome.header[ 73] = |  if ($nvtype eq 'float') {
MakeMaker::Awesome.header[ 74] = |    $ac->msg_notice("Use float for lua_Number");
MakeMaker::Awesome.header[ 75] = |    $CCFLAGS .= " -DLUA_FLOAT_TYPE=1";
MakeMaker::Awesome.header[ 76] = |  } elsif ($nvtype eq 'double') {
MakeMaker::Awesome.header[ 77] = |    $ac->msg_notice("Use double for lua_Number");
MakeMaker::Awesome.header[ 78] = |    $CCFLAGS .= " -DLUA_FLOAT_TYPE=2";
MakeMaker::Awesome.header[ 79] = |  } elsif ($nvtype eq 'long double') {
MakeMaker::Awesome.header[ 80] = |    $ac->msg_notice("Use long double for lua_Number");
MakeMaker::Awesome.header[ 81] = |    $CCFLAGS .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[ 82] = |  } else {
MakeMaker::Awesome.header[ 83] = |    $ac->msg_notice("No exact map found in lua for perl double type \"$nvtype\": use long double for lua_Number");
MakeMaker::Awesome.header[ 84] = |    $CCFLAGS .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[ 85] = |  }
MakeMaker::Awesome.header[ 86] = |  #
MakeMaker::Awesome.header[ 87] = |  # Get CMake version => 3.26
MakeMaker::Awesome.header[ 88] = |  #
MakeMaker::Awesome.header[ 89] = |  my $perl_exe = Probe::Perl->find_perl_interpreter();
MakeMaker::Awesome.header[ 90] = |  my @args = ($perl_exe, File::Spec->catfile('etc', 'get_cmake3.pl'), 'get_cmake3_result.txt');
MakeMaker::Awesome.header[ 91] = |  system(@args) == EXIT_SUCCESS || die "Cannot get cmake, $!";
MakeMaker::Awesome.header[ 92] = |  open(my $cmake3_result_fh, '<', 'get_cmake3_result.txt') || die "Cannot open get_cmake3_result.txt, $!";
MakeMaker::Awesome.header[ 93] = |  my $cmake3_exe = do { local $/; <$cmake3_result_fh> };
MakeMaker::Awesome.header[ 94] = |  close($cmake3_result_fh) || warn "Cannot close get_cmake3_result.txt, $!";
MakeMaker::Awesome.header[ 95] = |  print "Using $cmake3_exe\n";
MakeMaker::Awesome.header[ 96] = |  #
MakeMaker::Awesome.header[ 97] = |  # Build marpaESLIF
MakeMaker::Awesome.header[ 98] = |  #
MakeMaker::Awesome.header[ 99] = |  @args = ($perl_exe, File::Spec->catfile('etc', 'call_cmake3.pl'), $cmake3_exe);
MakeMaker::Awesome.header[100] = |  local $ENV{CCFLAGS} = $CCFLAGS;
MakeMaker::Awesome.header[101] = |  system(@args) == EXIT_SUCCESS || die "Cannot call cmake, $!";
MakeMaker::Awesome.header[102] = |}
MakeMaker::Awesome.header[103] = |
MakeMaker::Awesome.header[104] = |
MakeMaker::Awesome.header[105] = |
MakeMaker::Awesome.header[106] = |#
MakeMaker::Awesome.header[107] = |# Generate constant types
MakeMaker::Awesome.header[108] = |#
MakeMaker::Awesome.header[109] = |my $fh;
MakeMaker::Awesome.header[110] = |open($fh, '>', 'c-constant-types.inc') || die "Cannot open c-constant-types.inc, $!";
MakeMaker::Awesome.header[111] = |print $fh constant_types();
MakeMaker::Awesome.header[112] = |close($fh) || warn "Failed to close c-constant-types.inc, $!";
MakeMaker::Awesome.header[113] = |my %types = ( 'event' => { pkg => 'MarpaX::ESLIF::Event::Type', constants => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/] }, 'value' => { pkg => 'MarpaX::ESLIF::Value::Type', constants => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_BOOL MARPAESLIF_VALUE_TYPE_STRING MARPAESLIF_VALUE_TYPE_ROW MARPAESLIF_VALUE_TYPE_TABLE MARPAESLIF_VALUE_TYPE_LONG_DOUBLE/] }, 'loggerLevel' => { pkg => 'MarpaX::ESLIF::Logger::Level', constants => [qw/GENERICLOGGER_LOGLEVEL_TRACE GENERICLOGGER_LOGLEVEL_DEBUG GENERICLOGGER_LOGLEVEL_INFO GENERICLOGGER_LOGLEVEL_NOTICE GENERICLOGGER_LOGLEVEL_WARNING GENERICLOGGER_LOGLEVEL_ERROR GENERICLOGGER_LOGLEVEL_CRITICAL GENERICLOGGER_LOGLEVEL_ALERT GENERICLOGGER_LOGLEVEL_EMERGENCY/] }, 'rulePropertyBitSet' => { pkg => 'MarpaX::ESLIF::Rule::PropertyBitSet', constants => [qw/MARPAESLIF_RULE_IS_ACCESSIBLE MARPAESLIF_RULE_IS_NULLABLE MARPAESLIF_RULE_IS_NULLING MARPAESLIF_RULE_IS_LOOP MARPAESLIF_RULE_IS_PRODUCTIVE/] }, 'symbolPropertyBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::PropertyBitSet', constants => [qw/MARPAESLIF_SYMBOL_IS_ACCESSIBLE MARPAESLIF_SYMBOL_IS_NULLABLE MARPAESLIF_SYMBOL_IS_NULLING MARPAESLIF_SYMBOL_IS_PRODUCTIVE MARPAESLIF_SYMBOL_IS_START MARPAESLIF_SYMBOL_IS_TERMINAL/] }, 'symbolEventBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::EventBitSet', constants => [qw/MARPAESLIF_SYMBOL_EVENT_COMPLETION MARPAESLIF_SYMBOL_EVENT_NULLED MARPAESLIF_SYMBOL_EVENT_PREDICTION/] }, 'symbol' => { pkg => 'MarpaX::ESLIF::Symbol::Type', constants => [qw/MARPAESLIF_SYMBOLTYPE_TERMINAL MARPAESLIF_SYMBOLTYPE_META/] });
MakeMaker::Awesome.header[114] = |
MakeMaker::Awesome.header[115] = |foreach (sort keys %types) {
MakeMaker::Awesome.header[116] = |  my $pkg = $types{$_}->{pkg};
MakeMaker::Awesome.header[117] = |  print "Generating $pkg C $_ types\n";
MakeMaker::Awesome.header[118] = |  open($fh, '>', "c-$_-types.inc") || die "Cannot open c-$_-types.inc, $!";
MakeMaker::Awesome.header[119] = |  print $fh C_constant($pkg, "${_}_constant", undef, undef, undef, undef, @{$types{$_}->{constants}});
MakeMaker::Awesome.header[120] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[121] = |  #
MakeMaker::Awesome.header[122] = |  # This is a bit vicious but in our case these are NOT macros but ENUMS !
MakeMaker::Awesome.header[123] = |  # We know what were are doing and replace all #ifdef MARPAESLIF_xxx and #ifdef GENERICLOGGER_xxx by #if 1
MakeMaker::Awesome.header[124] = |  #
MakeMaker::Awesome.header[125] = |  print "Tweaking $pkg C $_ types to work with enums\n";
MakeMaker::Awesome.header[126] = |  open($fh, '<', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[127] = |  my $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[128] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[129] = |  $content =~ s/^#\s*ifdef\s+(?:MARPAESLIF_|GENERICLOGGER_).*?$/#if 1/smg;
MakeMaker::Awesome.header[130] = |  open($fh, '>', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[131] = |  print $fh $content;
MakeMaker::Awesome.header[132] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[133] = |
MakeMaker::Awesome.header[134] = |  print "Generating $pkg XS $_ types\n";
MakeMaker::Awesome.header[135] = |  open($fh, '>', "xs-$_-types.inc") || die "Cannot open xs-$_-types.inc, $!";
MakeMaker::Awesome.header[136] = |  print $fh XS_constant($pkg, 'IV', 'constant', "${_}_constant");
MakeMaker::Awesome.header[137] = |  close($fh) || warn "Failed to close xs-$_-types.inc, $!";
MakeMaker::Awesome.header[138] = |
MakeMaker::Awesome.header[139] = |  print "Generating $pkg AUTOLOAD\n";
MakeMaker::Awesome.header[140] = |  my $autoload = replace_autoload_tabs(autoload($pkg, '5.10', 1));
MakeMaker::Awesome.header[141] = |
MakeMaker::Awesome.header[142] = |  my @pkg = split(/::/, $pkg);
MakeMaker::Awesome.header[143] = |  $pkg[-1] .= '.pm';
MakeMaker::Awesome.header[144] = |  my $pkgfile = File::Spec->catfile('lib', @pkg);
MakeMaker::Awesome.header[145] = |  print "Pushing AUTOLOAD into $pkgfile\n";
MakeMaker::Awesome.header[146] = |  open($fh, '<', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[147] = |  $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[148] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[149] = |  $content =~ s/^#\s*AUTOLOAD.*?$/\n$autoload\n/sm;
MakeMaker::Awesome.header[150] = |  open($fh, '>', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[151] = |  print $fh $content;
MakeMaker::Awesome.header[152] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[153] = |}
MakeMaker::Awesome.header[154] = |
MakeMaker::Awesome.header[155] = |sub replace_autoload_tabs {
MakeMaker::Awesome.header[156] = |    my ($autoload) = @_;
MakeMaker::Awesome.header[157] = |    $autoload =~ s/^\t/        /mg; # For the cases we know for pretty indentation
MakeMaker::Awesome.header[158] = |    $autoload =~ s/\t/    /g; # For all the other cases
MakeMaker::Awesome.header[159] = |    return $autoload;
MakeMaker::Awesome.header[160] = |}
MakeMaker::Awesome.header[161] = |#
MakeMaker::Awesome.header[162] = |# Dependencies
MakeMaker::Awesome.header[163] = |#
MakeMaker::Awesome.header[164] = |my $libs = '-L' . File::Spec->rel2abs(File::Spec->catdir('stage', 'lib')) . ' -lmarpaESLIF_static -lmarpaWrapper_static -ltconv_static -lgenericLogger_static' . " $extra_linker_flags";
MakeMaker::Awesome.header[165] = |print "LIBS = $libs\n";
MakeMaker::Awesome.WriteMakefile_arg[0] = OBJECT => 'ESLIF$(OBJ_EXT)'
MakeMaker::Awesome.WriteMakefile_arg[1] = INC => "-I" . File::Spec->catdir('stage', 'include')
MakeMaker::Awesome.WriteMakefile_arg[2] = LIBS => $libs

; Do not require Thread on non-threaded perls
; ---------------------------------------------------
[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}
