name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; ---------------------------------------------------
; We use @Starter::Git with the following variations:
; ---------------------------------------------------

; Next version is provided by Git::NextVersion
; ---------------------------------------------------
[Git::NextVersion]
version_regexp = ^v?(\d+\.\d+)$

; "# VERSION" and "# AUTHORITY" annotations
; ---------------------------------------------------
[OurPkgVersion]
[Authority]
locate_comment = 1

; Pod are managed using Pod::Weaver::PluginBundle::RJBS
; ---------------------------------------------------
; - Because he knows how to insert Contributor section before Legal section
; - We add that explicitly to DevelopRequires because it seems it is not automatically discovered.
[Git::Contributors]
[PodWeaver]
config_plugin = @RJBS
[Prereqs / DevelopRequires ]
Pod::Weaver::PluginBundle::RJBS = 0

; Add authordeps as develop/requires
; ---------------------------------------------------
[Prereqs::AuthorDeps]

; Add xt tests
; ---------------------------------------------------
[Test::Perl::Critic]     ; xt/author/critic.t
[MetaTests]              ; xt/author/distmeta.t
[Test::EOL]              ; xt/author/eol.t
[Test::MinimumVersion]   ; xt/author/minimum-version.t
[MojibakeTests]          ; xt/author/mojibake.t
[Test::NoTabs]           ; xt/author/no-tabs.t
[PodCoverageTests]       ; xt/author/pod-coverage.t
[Test::Pod::LinkCheck]   ; xt/author/pod-linkcheck.t
[Test::Portability]      ; xt/author/portability.t
options = test_one_dot = 0
[Test::Synopsis]         ; xt/author/synopsis.t
[Test::Version]          ; xt/author/test-version.t
[Test::CPAN::Changes]    ; xt/release/cpan-changes.t
[Test::Kwalitee]         ; xt/release/kwalitee.t
[Test::CPAN::Meta::JSON] ; xt/release/meta-json.t

; Meta resources use [AutoMetaResources] convenient %{dist} to set homepage, [GitHub::Meta] for the rest
; ---------------------------------------------------
[AutoMetaResources]
homepage = https://metacpan.org/release/%{dist}
[GitHub::Meta]
homepage = 0

; Determine minimum perl version
; ---------------------------------------------------
[MinimumPerl]

; Generate a cpanfile
; ---------------------------------------------------
[CPANFile]

; Generate a Changes file
; ---------------------------------------------------
[ChangelogFromGit::CPAN::Changes]
file_name = Changes
group_by_author = 1 ; default 0
show_author_email = 1 ; default 0
tag_regexp  = ^v?(\d+\.\d+)$

; @Starter::Git Bundle with regeneration of:
; Makefile.PL
; META.json
; README.pod
; ---------------------------------------------------
[@Starter::Git]
revision = 5
-remove = Pod2Readme
Git::GatherDir.exclude_filename = LICENSE
Test::Compile.xt_mode = 0
Git::Check.allow_dirty[0] = Changes
Git::Check.allow_dirty[1] = META.json
Git::Check.allow_dirty[2] = README.pod
Git::Check.allow_dirty[3] = Makefile.PL
Git::Check.allow_dirty[4] = cpanfile
Git::Check.untracked_files = warn ; For the case where generated files do not yet exist
regenerate = Changes
regenerate = META.json
regenerate = README.pod
regenerate = Makefile.PL
regenerate = cpanfile
installer = MakeMaker::Awesome
MakeMaker::Awesome.delimiter = |
MakeMaker::Awesome.header[  0] = |use ExtUtils::Constant qw /constant_types C_constant XS_constant autoload/;
MakeMaker::Awesome.header[  1] = |use File::Spec;
MakeMaker::Awesome.header[  2] = |use File::Basename;
MakeMaker::Awesome.header[  3] = |use Alien::Build;
MakeMaker::Awesome.header[  4] = |
MakeMaker::Awesome.header[  5] = |print "Checking CMake\n";
MakeMaker::Awesome.header[  6] = |$ENV{PKG_CONFIG_PATH} ||= '';
MakeMaker::Awesome.header[  7] = |my $inc_dir   = File::Spec->catdir(File::Spec->curdir, 'inc');
MakeMaker::Awesome.header[  8] = |my $alienfile = File::Spec->catfile($inc_dir, 'cmake3', 'alienfile');
MakeMaker::Awesome.header[  9] = |my $prefix    = File::Spec->catdir($inc_dir, 'local');
MakeMaker::Awesome.header[ 10] = |my $stage     = File::Spec->catdir($inc_dir, 'stage');
MakeMaker::Awesome.header[ 11] = |
MakeMaker::Awesome.header[ 12] = |my $build = Alien::Build->load($alienfile);
MakeMaker::Awesome.header[ 13] = |$build->load_requires('configure');
MakeMaker::Awesome.header[ 14] = |$build->set_prefix($prefix);
MakeMaker::Awesome.header[ 15] = |$build->set_stage($stage);
MakeMaker::Awesome.header[ 16] = |$build->load_requires($build->install_type);
MakeMaker::Awesome.header[ 17] = |$build->download;
MakeMaker::Awesome.header[ 18] = |$build->build;
MakeMaker::Awesome.header[ 19] = |
MakeMaker::Awesome.header[ 20] = |my $cmake;
MakeMaker::Awesome.header[ 21] = |my $install_type = $build->runtime_prop->{install_type} // '';
MakeMaker::Awesome.header[ 22] = |if($install_type eq 'system') {
MakeMaker::Awesome.header[ 23] = |    $cmake = $build->runtime_prop->{command};
MakeMaker::Awesome.header[ 24] = |} elsif($install_type eq 'share') {
MakeMaker::Awesome.header[ 25] = |    $cmake = $build->runtime_prop->{command};
MakeMaker::Awesome.header[ 26] = |    if (! File::Spec->file_name_is_absolute($cmake)) {
MakeMaker::Awesome.header[ 27] = |        $cmake = File::Spec->catfile($stage, $cmake);
MakeMaker::Awesome.header[ 28] = |    }
MakeMaker::Awesome.header[ 29] = |} else {
MakeMaker::Awesome.header[ 30] = |    die "Unknown install type $install_type";
MakeMaker::Awesome.header[ 31] = |}
MakeMaker::Awesome.header[ 32] = |print "Using $cmake\n";
MakeMaker::Awesome.header[ 33] = |
MakeMaker::Awesome.header[ 34] = |
MakeMaker::Awesome.header[ 35] = |my $fh;
MakeMaker::Awesome.header[ 36] = |print "Generating constant types\n";
MakeMaker::Awesome.header[ 37] = |open($fh, '>', 'c-constant-types.inc') || die "Cannot open c-constant-types.inc, $!";
MakeMaker::Awesome.header[ 38] = |print $fh constant_types();
MakeMaker::Awesome.header[ 39] = |close($fh) || warn "Failed to close c-constant-types.inc, $!";
MakeMaker::Awesome.header[ 40] = |
MakeMaker::Awesome.header[ 41] = |my %types = ( 'event' => { pkg => 'MarpaX::ESLIF::Event::Type', constants => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/] }, 'value' => { pkg => 'MarpaX::ESLIF::Value::Type', constants => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_BOOL MARPAESLIF_VALUE_TYPE_STRING MARPAESLIF_VALUE_TYPE_ROW MARPAESLIF_VALUE_TYPE_TABLE MARPAESLIF_VALUE_TYPE_LONG_DOUBLE/] }, 'loggerLevel' => { pkg => 'MarpaX::ESLIF::Logger::Level', constants => [qw/GENERICLOGGER_LOGLEVEL_TRACE GENERICLOGGER_LOGLEVEL_DEBUG GENERICLOGGER_LOGLEVEL_INFO GENERICLOGGER_LOGLEVEL_NOTICE GENERICLOGGER_LOGLEVEL_WARNING GENERICLOGGER_LOGLEVEL_ERROR GENERICLOGGER_LOGLEVEL_CRITICAL GENERICLOGGER_LOGLEVEL_ALERT GENERICLOGGER_LOGLEVEL_EMERGENCY/] }, 'rulePropertyBitSet' => { pkg => 'MarpaX::ESLIF::Rule::PropertyBitSet', constants => [qw/MARPAESLIF_RULE_IS_ACCESSIBLE MARPAESLIF_RULE_IS_NULLABLE MARPAESLIF_RULE_IS_NULLING MARPAESLIF_RULE_IS_LOOP MARPAESLIF_RULE_IS_PRODUCTIVE/] }, 'symbolPropertyBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::PropertyBitSet', constants => [qw/MARPAESLIF_SYMBOL_IS_ACCESSIBLE MARPAESLIF_SYMBOL_IS_NULLABLE MARPAESLIF_SYMBOL_IS_NULLING MARPAESLIF_SYMBOL_IS_PRODUCTIVE MARPAESLIF_SYMBOL_IS_START MARPAESLIF_SYMBOL_IS_TERMINAL/] }, 'symbolEventBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::EventBitSet', constants => [qw/MARPAESLIF_SYMBOL_EVENT_COMPLETION MARPAESLIF_SYMBOL_EVENT_NULLED MARPAESLIF_SYMBOL_EVENT_PREDICTION/] }, 'symbol' => { pkg => 'MarpaX::ESLIF::Symbol::Type', constants => [qw/MARPAESLIF_SYMBOLTYPE_TERMINAL MARPAESLIF_SYMBOLTYPE_META/] });
MakeMaker::Awesome.header[ 42] = |
MakeMaker::Awesome.header[ 43] = |foreach (sort keys %types) {
MakeMaker::Awesome.header[ 44] = |  my $pkg = $types{$_}->{pkg};
MakeMaker::Awesome.header[ 45] = |  print "Generating $pkg C $_ types\n";
MakeMaker::Awesome.header[ 46] = |  open($fh, '>', "c-$_-types.inc") || die "Cannot open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 47] = |  print $fh C_constant($pkg, "${_}_constant", undef, undef, undef, undef, @{$types{$_}->{constants}});
MakeMaker::Awesome.header[ 48] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 49] = |
MakeMaker::Awesome.header[ 50] = |  # This is a bit vicious but in our case these are NOT macros but ENUMS !
MakeMaker::Awesome.header[ 51] = |  # We know what were are doing and replace all #ifdef MARPAESLIF_xxx and #ifdef GENERICLOGGER_xxx by #if 1
MakeMaker::Awesome.header[ 52] = |
MakeMaker::Awesome.header[ 53] = |  print "Tweaking $pkg C $_ types to work with enums\n";
MakeMaker::Awesome.header[ 54] = |  open($fh, '<', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 55] = |  my $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[ 56] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 57] = |  $content =~ s/^#\s*ifdef\s+(?:MARPAESLIF_|GENERICLOGGER_).*?$/#if 1/smg;
MakeMaker::Awesome.header[ 58] = |  open($fh, '>', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 59] = |  print $fh $content;
MakeMaker::Awesome.header[ 60] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[ 61] = |
MakeMaker::Awesome.header[ 62] = |  print "Generating $pkg XS $_ types\n";
MakeMaker::Awesome.header[ 63] = |  open($fh, '>', "xs-$_-types.inc") || die "Cannot open xs-$_-types.inc, $!";
MakeMaker::Awesome.header[ 64] = |  print $fh XS_constant($pkg, 'IV', 'constant', "${_}_constant");
MakeMaker::Awesome.header[ 65] = |  close($fh) || warn "Failed to close xs-$_-types.inc, $!";
MakeMaker::Awesome.header[ 66] = |
MakeMaker::Awesome.header[ 67] = |  print "Generating $pkg AUTOLOAD\n";
MakeMaker::Awesome.header[ 68] = |  my $autoload = replace_autoload_tabs(autoload($pkg, '5.10', 1));
MakeMaker::Awesome.header[ 69] = |
MakeMaker::Awesome.header[ 70] = |  my @pkg = split(/::/, $pkg);
MakeMaker::Awesome.header[ 71] = |  $pkg[-1] .= '.pm';
MakeMaker::Awesome.header[ 72] = |  my $pkgfile = File::Spec->catfile('lib', @pkg);
MakeMaker::Awesome.header[ 73] = |  print "Pushing AUTOLOAD into $pkgfile\n";
MakeMaker::Awesome.header[ 74] = |  open($fh, '<', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[ 75] = |  $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[ 76] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[ 77] = |  $content =~ s/^#\s*AUTOLOAD.*?$/\n$autoload\n/sm;
MakeMaker::Awesome.header[ 78] = |  open($fh, '>', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[ 79] = |  print $fh $content;
MakeMaker::Awesome.header[ 80] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[ 81] = |}
MakeMaker::Awesome.header[ 82] = |sub replace_autoload_tabs {
MakeMaker::Awesome.header[ 83] = |    my ($autoload) = @_;
MakeMaker::Awesome.header[ 84] = |    $autoload =~ s/^\t/        /mg; # For the cases we know for pretty indentation
MakeMaker::Awesome.header[ 85] = |    $autoload =~ s/\t/    /g; # For all the other cases
MakeMaker::Awesome.header[ 86] = |    return $autoload;
MakeMaker::Awesome.header[ 87] = |}
MakeMaker::Awesome.header[ 88] = |
MakeMaker::Awesome.header[ 89] = |print "Checking marpaESLIF\n";
MakeMaker::Awesome.header[ 90] = |my $incmarpaESLIF = File::Spec->catdir($inc_dir, 'marpaESLIF');
MakeMaker::Awesome.header[ 91] = |my @args = ($cmake, '-S', $incmarpaESLIF, '-B', "${incmarpaESLIF}-build", '-DCMAKE_BUILD_TYPE=Release');
MakeMaker::Awesome.header[ 92] = |system(@args) == 0 or die "system @args failed: $?";
MakeMaker::Awesome.WriteMakefile_arg[0] = OBJECT => 'ESLIF$(OBJ_EXT)'

; Do not require Thread on non-threaded perls
; ---------------------------------------------------
[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}
